<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Support AI Chatbot</title>
<style>
  body { 
    font-family: Arial, sans-serif; 
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    margin: 0; 
    padding: 0; 
    min-height: 100vh;
  }
  .chat-container { 
    width: 90%; 
    max-width: 700px; 
    margin: 30px auto; 
    background: #fff; 
    border-radius: 12px; 
    box-shadow: 0 10px 30px rgba(0,0,0,0.2); 
    padding: 20px;
    display: flex;
    flex-direction: column;
    height: calc(100vh - 80px);
    max-height: 800px;
  }
  h2 { 
    margin: 0 0 15px 0; 
    color: #333; 
    display: flex; 
    justify-content: space-between; 
    align-items: center;
    padding-bottom: 15px;
    border-bottom: 2px solid #f0f0f0;
  }
  .header-title {
    display: flex;
    align-items: center;
    gap: 10px;
  }
  .controls {
    display: flex;
    gap: 8px;
  }
  .icon-btn {
    background: none;
    border: none;
    cursor: pointer;
    font-size: 20px;
    padding: 8px;
    border-radius: 50%;
    transition: background 0.3s;
  }
  .icon-btn:hover {
    background: #f0f0f0;
  }
  .icon-btn.active {
    background: #e3f2fd;
    color: #1976d2;
  }
  .icon-btn.speaking {
    background: #c8e6c9;
    color: #2e7d32;
    animation: speakPulse 1s infinite;
  }
  @keyframes speakPulse {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.1); }
  }
  .chat-box { 
    flex: 1;
    overflow-y: auto; 
    border: 1px solid #e0e0e0; 
    padding: 15px; 
    border-radius: 8px; 
    margin-bottom: 15px; 
    background: #fafafa;
    scroll-behavior: smooth;
  }
  .chat-message { 
    margin: 12px 0; 
    padding: 12px 16px; 
    border-radius: 18px; 
    max-width: 75%; 
    word-wrap: break-word; 
    display: block; 
    line-height: 1.5;
    animation: slideIn 0.3s ease-out;
  }
  @keyframes slideIn {
    from {
      opacity: 0;
      transform: translateY(10px);
    }
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }
  .user { 
    color: #fff; 
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    margin-left: auto; 
    text-align: right;
    border-bottom-right-radius: 4px;
  }
  .ai { 
    color: #333; 
    background: #e9ecef;
    margin-right: auto;
    border-bottom-left-radius: 4px;
    box-shadow: 0 1px 2px rgba(0,0,0,0.1);
  }
  .info-message { 
    text-align: center; 
    color: #999; 
    padding: 20px; 
    font-style: italic; 
  }
  .input-container { 
    display: flex; 
    gap: 10px; 
    align-items: center;
    background: #f8f9fa;
    padding: 15px;
    border-radius: 8px;
  }
  input[type="text"] { 
    flex: 1; 
    padding: 12px 16px; 
    border: 2px solid #e0e0e0; 
    border-radius: 25px; 
    font-size: 14px;
    transition: border-color 0.3s;
  }
  input[type="text"]:focus {
    outline: none;
    border-color: #667eea;
  }
  .btn-group {
    display: flex;
    gap: 8px;
  }
  button { 
    padding: 12px 24px; 
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white; 
    border: none; 
    border-radius: 25px; 
    cursor: pointer; 
    font-size: 14px;
    font-weight: 600;
    transition: transform 0.2s, box-shadow 0.2s;
  }
  button:hover { 
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
  }
  button:active {
    transform: translateY(0);
  }
  button:disabled { 
    background: #ccc; 
    cursor: not-allowed;
    transform: none;
  }
  .voice-btn {
    width: 48px;
    height: 48px;
    border-radius: 50%;
    padding: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 20px;
  }
  .voice-btn.recording {
    background: #dc3545;
    animation: pulse 1.5s infinite;
  }
  @keyframes pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.7; }
  }
  .error { 
    color: #dc3545; 
    background: #f8d7da; 
    padding: 12px; 
    border-radius: 8px; 
    margin: 10px 0; 
    text-align: center;
    border-left: 4px solid #dc3545;
  }
  .success {
    color: #155724;
    background: #d4edda;
    padding: 12px;
    border-radius: 8px;
    margin: 10px 0;
    text-align: center;
    border-left: 4px solid #28a745;
  }
  .typing-indicator {
    display: inline-block;
    padding: 10px 15px;
    background: #e9ecef;
    border-radius: 18px;
    margin-right: auto;
  }
  .typing-indicator span {
    height: 8px;
    width: 8px;
    background: #999;
    display: inline-block;
    border-radius: 50%;
    margin: 0 2px;
    animation: typing 1.4s infinite;
  }
  .typing-indicator span:nth-child(2) {
    animation-delay: 0.2s;
  }
  .typing-indicator span:nth-child(3) {
    animation-delay: 0.4s;
  }
  @keyframes typing {
    0%, 60%, 100% { transform: translateY(0); }
    30% { transform: translateY(-10px); }
  }
  
  /* Scrollbar styling */
  .chat-box::-webkit-scrollbar {
    width: 8px;
  }
  .chat-box::-webkit-scrollbar-track {
    background: #f1f1f1;
    border-radius: 4px;
  }
  .chat-box::-webkit-scrollbar-thumb {
    background: #888;
    border-radius: 4px;
  }
  .chat-box::-webkit-scrollbar-thumb:hover {
    background: #555;
  }
</style>
</head>
<body>

<div class="chat-container">
  <h2>
    <div class="header-title">
      <span>ü§ñ</span>
      <span>Support AI Chatbot</span>
    </div>
    <div class="controls">
      <!-- <button class="icon-btn" id="clear-btn" onclick="clearChat()" title="Clear Chat">üóëÔ∏è</button> -->
      <button class="icon-btn active" id="voice-toggle" onclick="toggleVoice()" title="Toggle Voice Response">üîä</button>
    </div>
  </h2>
  
  <div id="chat-box" class="chat-box">
    <div class="info-message">Loading chat history...</div>
  </div>
  
  <div class="input-container">
    <input type="text" id="user-input" placeholder="Type your message..." onkeypress="handleKeyPress(event)" />
    <div class="btn-group">
      <button class="voice-btn" id="voice-btn" onclick="toggleVoiceInput()" title="Voice Input">üé§</button>
      <button id="send-btn" onclick="sendMessage()">Send</button>
    </div>
  </div>
</div>

<script>
const chatBox = document.getElementById('chat-box');
const sendBtn = document.getElementById('send-btn');
const userInput = document.getElementById('user-input');
const voiceBtn = document.getElementById('voice-btn');
const voiceToggle = document.getElementById('voice-toggle');
const API_BASE = '/chat';

// Voice settings
let isVoiceEnabled = true;
let isRecording = false;
let recognition = null;
let speechSynthesis = window.speechSynthesis;
let currentUtterance = null;
let isSpeaking = false;

// Speech queue for streaming
let speechQueue = [];
let isProcessingQueue = false;

// Initialize Speech Recognition
if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
  const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
  recognition = new SpeechRecognition();
  recognition.continuous = false;
  recognition.interimResults = false;
  recognition.lang = 'en-US';

  recognition.onresult = (event) => {
    const transcript = event.results[0][0].transcript;
    userInput.value = transcript;
    isRecording = false;
    voiceBtn.classList.remove('recording');
    voiceBtn.textContent = 'üé§';
  };

  recognition.onerror = (event) => {
    console.error('Speech recognition error:', event.error);
    isRecording = false;
    voiceBtn.classList.remove('recording');
    voiceBtn.textContent = 'üé§';
    showNotification('Voice recognition error: ' + event.error, 'error');
  };

  recognition.onend = () => {
    isRecording = false;
    voiceBtn.classList.remove('recording');
    voiceBtn.textContent = 'üé§';
  };
} else {
  voiceBtn.style.display = 'none';
  console.warn('Speech recognition not supported');
}

// Toggle voice input
function toggleVoiceInput() {
  if (!recognition) {
    showNotification('Voice input not supported in your browser', 'error');
    return;
  }

  if (isRecording) {
    recognition.stop();
    isRecording = false;
    voiceBtn.classList.remove('recording');
    voiceBtn.textContent = 'üé§';
  } else {
    recognition.start();
    isRecording = true;
    voiceBtn.classList.add('recording');
    voiceBtn.textContent = '‚èπÔ∏è';
  }
}

// Toggle voice output
function toggleVoice() {
  isVoiceEnabled = !isVoiceEnabled;
  voiceToggle.classList.toggle('active', isVoiceEnabled);
  voiceToggle.textContent = isVoiceEnabled ? 'üîä' : 'üîá';
  
  if (!isVoiceEnabled) {
    stopSpeaking();
    voiceToggle.classList.remove('speaking');
  }
  
  showNotification(isVoiceEnabled ? 'Voice responses enabled' : 'Voice responses disabled', 'success');
}

// Stop all speech
function stopSpeaking() {
  if (speechSynthesis) {
    speechSynthesis.cancel();
  }
  speechQueue = [];
  isProcessingQueue = false;
  isSpeaking = false;
  voiceToggle.classList.remove('speaking');
}

// Process speech queue for streaming
async function processSpeechQueue() {
  if (isProcessingQueue || speechQueue.length === 0 || !isVoiceEnabled) {
    return;
  }

  isProcessingQueue = true;
  isSpeaking = true;
  voiceToggle.classList.add('speaking');

  while (speechQueue.length > 0 && isVoiceEnabled) {
    const text = speechQueue.shift();
    
    // Skip if text is too short or just punctuation
    if (text.trim().length < 2) continue;

    await speakText(text);
  }

  isProcessingQueue = false;
  isSpeaking = false;
  voiceToggle.classList.remove('speaking');
}

// Speak text with promise
function speakText(text) {
  return new Promise((resolve) => {
    if (!isVoiceEnabled || !speechSynthesis) {
      resolve();
      return;
    }

    const utterance = new SpeechSynthesisUtterance(text);
    utterance.rate = 1.1;
    utterance.pitch = 1.0;
    utterance.volume = 1.0;

    const voices = speechSynthesis.getVoices();
    const englishVoice = voices.find(voice => voice.lang.startsWith('en'));
    if (englishVoice) {
      utterance.voice = englishVoice;
    }

    utterance.onend = () => {
      resolve();
    };

    utterance.onerror = () => {
      resolve();
    };

    currentUtterance = utterance;
    speechSynthesis.speak(utterance);
  });
}

// Add text to speech queue (for streaming)
function queueSpeech(text) {
  if (!isVoiceEnabled) return;

  // Split text into sentences for better streaming
  const sentences = text.match(/[^.!?]+[.!?]+/g) || [text];
  
  sentences.forEach(sentence => {
    const trimmed = sentence.trim();
    if (trimmed.length > 0) {
      speechQueue.push(trimmed);
    }
  });

  // Start processing if not already
  if (!isProcessingQueue) {
    processSpeechQueue();
  }
}

// Handle Enter key
function handleKeyPress(event) {
  if (event.key === 'Enter' && !event.shiftKey) {
    event.preventDefault();
    sendMessage();
  }
}

// Add message
function addMessage(text, type) {
  const div = document.createElement('div');
  div.className = `chat-message ${type}`;
  div.textContent = text;
  chatBox.appendChild(div);
  chatBox.scrollTop = chatBox.scrollHeight;
  return div;
}

// Show typing indicator
function showTyping() {
  const typingDiv = document.createElement('div');
  typingDiv.className = 'typing-indicator';
  typingDiv.id = 'typing';
  typingDiv.innerHTML = '<span></span><span></span><span></span>';
  chatBox.appendChild(typingDiv);
  chatBox.scrollTop = chatBox.scrollHeight;
  return typingDiv;
}

// Remove typing indicator
function removeTyping() {
  const typing = document.getElementById('typing');
  if (typing) typing.remove();
}

// Show notification
function showNotification(message, type = 'success') {
  const div = document.createElement('div');
  div.className = type;
  div.textContent = message;
  chatBox.appendChild(div);
  chatBox.scrollTop = chatBox.scrollHeight;
  
  setTimeout(() => div.remove(), 3000);
}

// Load chat history
async function loadHistory() {
  try {
    const res = await fetch(`${API_BASE}/history`, { credentials: 'include' });
    
    if (!res.ok) {
      throw new Error(`Server returned ${res.status}`);
    }
    
    const data = await res.json();
    
    chatBox.innerHTML = '';
    
    if (!Array.isArray(data) || data.length === 0) {
      chatBox.innerHTML = '<div class="info-message">No chat history yet. Start a conversation! üëã</div>';
      return;
    }
    
    // Show last 10 messages
    const lastMessages = data.slice(-10);
    lastMessages.forEach(item => {
      addMessage(item.question, 'user');
      addMessage(item.answer, 'ai');
    });
    
  } catch (err) {
    console.error('Load history error:', err);
    chatBox.innerHTML = `<div class="error">Failed to load chat history: ${err.message}</div>`;
  }
}

// Clear chat
async function clearChat() {
  if (!confirm('Are you sure you want to clear the chat history?')) return;
  
  stopSpeaking();
  chatBox.innerHTML = '<div class="info-message">Chat cleared. Start a new conversation! üëã</div>';
}

// Send message with streaming AND voice streaming
async function sendMessage() {
  const text = userInput.value.trim();
  if (!text) return;

  sendBtn.disabled = true;
  sendBtn.textContent = 'Sending...';
  voiceBtn.disabled = true;

  // Stop any ongoing speech
  stopSpeaking();

  addMessage(text, 'user');
  userInput.value = '';

  // Show typing indicator
  const typing = showTyping();

  try {
    const formData = new FormData();
    formData.append('text', text);
    formData.append('user_id', 'default_user');

    const res = await fetch(`${API_BASE}/stream`, {
      method: 'POST',
      body: formData,
      credentials: 'include'
    });

    if (!res.ok) throw new Error(`Server returned ${res.status}`);

    removeTyping();

    const reader = res.body.getReader();
    const decoder = new TextDecoder();

    const aiDiv = addMessage('', 'ai');
    let aiText = '';
    let pendingSpeech = '';

    // ‚úÖ KEY FIX: Process chunks as they arrive
    while (true) {
      const { value, done } = await reader.read();
      if (done) break;
      
      const chunk = decoder.decode(value, { stream: true });
      aiText += chunk;
      aiDiv.textContent = aiText;
      chatBox.scrollTop = chatBox.scrollHeight;

      // ‚úÖ Add chunk to pending speech
      pendingSpeech += chunk;

      // ‚úÖ Speak when we have complete sentences
      const sentences = pendingSpeech.match(/[^.!?]+[.!?]+/g);
      if (sentences && sentences.length > 0) {
        // Speak complete sentences
        sentences.forEach(sentence => {
          queueSpeech(sentence);
        });
        
        // Keep remaining text
        pendingSpeech = pendingSpeech.substring(
          sentences.join('').length
        );
      }
    }

    // ‚úÖ Speak any remaining text
    if (pendingSpeech.trim().length > 0) {
      queueSpeech(pendingSpeech);
    }

  } catch (err) {
    removeTyping();
    stopSpeaking();
    addMessage(`Error: ${err.message}`, 'ai');
    console.error('Send message error:', err);
  } finally {
    sendBtn.disabled = false;
    sendBtn.textContent = 'Send';
    voiceBtn.disabled = false;
    userInput.focus();
  }
}

// Initialize
window.onload = () => {
  loadHistory();
  userInput.focus();
  
  // Load voices for speech synthesis
  if (speechSynthesis) {
    speechSynthesis.getVoices();
    speechSynthesis.onvoiceschanged = () => {
      speechSynthesis.getVoices();
    };
  }
};

// Stop speech when user starts typing
userInput.addEventListener('input', () => {
  stopSpeaking();
});

// Stop speech when user clicks send
sendBtn.addEventListener('click', () => {
  stopSpeaking();
});
</script>

</body>
</html>
